---
output: pdf_document
---
Peak retention times 
========================================================

We want to know whether the different software tools choose (in general) the same peak (based on retention time).

```{r set_options, echo=FALSE, message=FALSE}
require(knitr)
opts_chunk$set(echo = FALSE)


ambiguous.col   <- rgb(125/255, 125/255, 125/255, 1)
black.col       <- rgb(  0/255,   0/255,   0/255, 1)
DIAumpire.col   <- rgb(254/255, 218/255, 140/255, 1)
OpenSWATH.col   <- rgb(174/255, 230/255, 252/255, 1)
SWATH2.0.col    <- rgb(249/255, 143/255, 115/255, 1)
Skyline.col     <- rgb(177/255, 158/255, 223/255, 1)
Spectronaut.col <- rgb(173/255, 230/255, 150/255, 1)

palvector <- c(Ambiguous   = ambiguous.col,
               None        = black.col,
               DIAumpire   = DIAumpire.col, 
               OpenSWATH   = OpenSWATH.col,
               SWATH2.0    = SWATH2.0.col,
               Skyline     = Skyline.col,
               Spectronaut = Spectronaut.col)

color.order = c(None        = -2,
                Ambiguous   = -1,
                DIAumpire   =  1, 
                Skyline     =  2,
                OpenSWATH   =  3,
                SWATH2.0    =  4,
                Spectronaut =  5)

panel.diff <- function(x, y, ...) {
    delta = (x - y)
    points(x=x, y=delta, bty="n", ...)
    box(lwd=2)
}

panel.pair2 <- function(x, y, ...) {
    points(x=x, y=y, bty="n", ...)
    box(lwd=2)
}

panel.paired_outliers <- function(x, y, outl.threshold=0.2, ...){
    colorpal = c("red", "black")
    outliers = ifelse( abs(x-y) >= outl.threshold, 1, 2 )
    points(x=x, y=y, col=colorpal[outliers], ...)
}

panel.hist <- function(x, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks; nB <- length(breaks)
    y <- h$counts; y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, ...)
}

panel.txt <- function(x, y, labels, cex, font, ...)
{
    lab <- labels
    lab <- gsub(pattern="_int", "", lab)
    text(0.5, 0.5, lab, cex=cex, font=font)
}


```

```{r loadlibs}

loadLibrary <- function(x) 
{
  if(!require(x, character.only=T, quietly = T, warn.conflicts=F)) 
  { 
    install.packages(x); library(x, character.only=T, warn.conflicts=F) 
  } 
}

loadLibrary("VennDiagram")
loadLibrary("tidyr")
loadLibrary("dplyr")
loadLibrary("ggplot2")
loadLibrary("readxl")
loadLibrary("classInt")
loadLibrary("scales")
loadLibrary("pander")
loadLibrary("GGally")

```



Following software tool results are analyzed:  
1. Spectronaut    
2. Skyline  
3. SWATH2.0  
4. OpenSWATH  
5. DIAumpire  

We choose one of the injections: lgillet_I150211_008.wiff    

```{r loaddata, cache=TRUE, cache.lazy=TRUE, cache.comments=TRUE}

injection <- "lgillet_I150211_008"


## File names ##
spectronaut.file <- "/Users/napedro/Dropbox/PAPER_SWATHbenchmark_prv/output.from.softwares/draft.v2/iteration2/TTOF6600_64w/Spectronaut_20150522_140931_TTOF6600_64w_newLib_Report.tsv"
skyline.file <- "/Users/napedro/Dropbox/PAPER_SWATHbenchmark_prv/output.from.softwares/draft.v2/iteration2/TTOF6600_64w/Skyline_TTOF6600_64w_centroid_10minAs5_100Krp.tsv"
SWATH2.0.file <- "/Users/napedro/Dropbox/PAPER_SWATHbenchmark_prv/output.from.softwares/draft.v2/iteration2/TTOF6600_64w/PeakView_TTOF6600_64w_shift_iRT_extractionWindow10min_30ppm.xlsx"
openswath.file <- "/Users/napedro/Dropbox/PAPER_SWATHbenchmark_prv/output.from.softwares/draft.v2/iteration2/TTOF6600_64w/OpenSWATH_6600SW64_round2_30ppm_E1508100902_feature_alignment.tsv.gz"
diaumpire.file <- "/Users/napedro/Dropbox/PAPER_SWATHbenchmark_prv/output.from.softwares/draft.v2/iteration1/TTOF6600_64w/DIAumpire_6600_64_PeptideSummary.tsv"

q_filter_threshold <- 0.01

## SWATH2.0 ##
sequence.mod.var <- "Peptide"
charge.var <- "Precursor Charge"
fdr.var.tag <- "FDR"
quantitative.var <- "TotalAreaFragment"
quantitative.var.tag <- "Sample"

df.rt <- read_excel(SWATH2.0.file, sheet="Observed RT", col_names=T )
df.int <- read_excel(SWATH2.0.file, sheet="Area - peptides", col_names=T )
df.fdr <- read_excel(SWATH2.0.file, sheet="FDR", col_names=T )

df.fdr_rt <- cbind(df.fdr, df.rt[, 8:13])

df.fdr_rt <- df.fdr_rt[, grepl(injection, colnames(df.fdr_rt), ignore.case=T)]
df.fdr_rt <- cbind(df.rt[, 2:5], df.rt[, 7], df.fdr_rt)
df.fdr_rt$Label <- NULL
names(df.fdr_rt) <- c("Peptide", "mz", "z", "Decoy", "FDR", "RT" )
df.fdr_rt <- df.fdr_rt %>% filter(FDR <= q_filter_threshold)

df.int <- cbind(df.int[, 2:4], 
                df.int[, grepl(injection, colnames(df.int), ignore.case=T)])
names(df.int) <- c("Peptide", "mz", "z", "Intensity")


df.fdr_rt$sequence_z <- paste(df.fdr_rt$Peptide, df.fdr_rt$z, sep="_")
df.int$sequence_z <- paste(df.int$Peptide, df.int$z, sep="_" )

#remove possible duplicates
df.int <- df.int %>% filter(!duplicated(sequence_z))
df.fdr_rt <- df.fdr_rt %>% filter(!duplicated(sequence_z))

df <- inner_join(df.int, df.fdr_rt, by="sequence_z")
df <- df %>% filter(!is.na(FDR) & Decoy == "False") 

SWATH2.0 <- as.data.frame(cbind(
                                df$sequence_z,
                                gsub( "*\\[.*?\\]", "", df$Peptide.x ),
                                df$Peptide.x, 
                                df$mz.x, 
                                df$z.x, 
                                df$Intensity, 
                                df$RT, 
                                rep("SWATH2.0", nrow(df))
                                )
                          )
names(SWATH2.0) <- c("sequence_z", "Sequence", "Peptide", "mz", "z", "Intensity", "RT", "tool")
rm(df.fdr); rm(df.fdr_rt); rm(df.int); rm(df.rt); rm(df)

## DIA-Umpire ##
quantitative.var.tag <- "top6"
quantitative.var <- "top6Area"
protein.var <- "Protein"
filename.var <- "ReplicateName"
sequence.mod.var <- "ModSeq"
charge.var <- "Charge"

df <- read.table(diaumpire.file, na.strings= "NA", header=T, 
                         sep="\t", stringsAsFactors =F, fill = T) 
df.vars <- df[, grepl(injection, colnames(df) , ignore.case=T)]

diaumpire <- as.data.frame(cbind(
            paste(df$Sequence, df$Charge, sep="_"),
            df$Sequence,
            df$ModSeq,
            df$mz,
            df$Charge,
            df.vars[, grepl(quantitative.var.tag, colnames(df.vars) , ignore.case=T)],
            df.vars[, grepl("RT", colnames(df.vars) , ignore.case=T)],
            rep("DIAumpire", nrow(df))
                            )
                    )
names(diaumpire) <- c("sequence_z", "Sequence", "Peptide", "mz", "z", "Intensity", "RT", "tool")
rm(df.vars); rm(df)


## Skyline ##
q_filter_threshold <- 0.01
nastrings <- "#N/A"

df <- read.table(skyline.file, na.strings= nastrings, header=T, 
                         sep="\t", stringsAsFactors =F, fill = T) 
df <- df %>% filter(grepl(injection, FileName)) %>%
        filter(IsDecoy == "False") %>%
        filter(annotation_QValue <= q_filter_threshold)

skyline <- as.data.frame(cbind(
                                paste(df$PeptideModifiedSequence, df$PrecursorCharge, sep="_"),
                                df$PeptideSequence,
                                df$PeptideModifiedSequence,
                                df$PrecursorNeutralMass,
                                df$PrecursorCharge,
                                df$TotalArea,
                                df$BestRetentionTime,
                                rep("Skyline", nrow(df))
                            )
                        )

names(skyline) <- c("sequence_z", "Sequence", "Peptide", "mz", "z", "Intensity", "RT", "tool")


## Spectronaut ##
nastrings <- "NaN"

qvalue.var <- "EG.Qvalue"
protein.var <- "EG.ProteinId"
input.extension <- "*.tsv$"
input_format <- "long"  # Options: "long", "wide"

df <- read.table(spectronaut.file, na.strings= nastrings, header=T, 
                         sep="\t", stringsAsFactors =F, fill = T) 

df <- df %>% filter(grepl(injection, R.FileName)) 

spectronaut <- as.data.frame(cbind(
                                paste(df$EG.ModifiedSequence, df$FG.Charge, sep="_"),
                                df$EG.StrippedSequence,
                                df$EG.ModifiedSequence,
                                df$FG.PrecMz,
                                df$FG.Charge,
                                df$FG.NormalizedTotalPeakArea,
                                df$EG.MeanApexRT,
                                rep("Spectronaut", nrow(df))
                                )
                            )
names(spectronaut) <- c("sequence_z", "Sequence", "Peptide", "mz", "z", "Intensity", "RT", "tool")

## OpenSWATH ##
q_filter_threshold <- 0.01
quantitative.var <- "Intensity"
protein.var <- "ProteinName"
sequence.mod.var <- "FullPeptideName"
charge.var <- "Charge"  

df <- read.table(openswath.file, header=T, 
                         sep="\t", stringsAsFactors =F, fill = T) 

df <- df %>% filter(grepl(injection, filename, ignore.case=T)) %>%
        filter(decoy == F) %>%
        filter(m_score <= q_filter_threshold)

openswath <- as.data.frame(cbind(
                           paste(df$FullPeptideName, df$Charge, sep="_"),
                           df$Sequence,
                           df$FullPeptideName,
                           df$m.z,
                           df$Charge,
                           df$Intensity,
                           df$RT / 60, 
                           rep("OpenSWATH", nrow(df))
                           ))

names(openswath) <- c("sequence_z", "Sequence", "Peptide", "mz", "z", "Intensity", "RT", "tool")
rm(df)

# join all to a single data frame
rts <- rbind(spectronaut, skyline)
rts <- rbind(rts, SWATH2.0)
rts <- rbind(rts, openswath)
rts <- rbind(rts, diaumpire)

rts <- rts %>%
    mutate( 
        sequence_z = as.character(sequence_z),
        Sequence = as.character(Sequence),
        Peptide = as.character(Peptide),
        mz = as.numeric(as.character(mz)),
        z = as.numeric(as.character(z)),
        Intensity = as.numeric(as.character(Intensity)),
        RT = as.numeric(as.character(RT)),
        tool = as.character(tool)
        )

```


Modifications are reported differently in each software. As a first approach I use only non modified peptides.

```{r filterMods}

# remove modifications
total_assays = length(unique(rts$Peptide))
total_peptides = length(unique(rts$Sequence))
removed_assays = total_assays - total_peptides
rts <- rts %>% filter( Sequence == Peptide )

rts_count <- rts %>% group_by(tool) %>% summarise(n())

rts_w <- rts %>% select(Sequence, z, tool, RT) %>% spread(key=tool, value=RT)
rts_w$numNAs <- numNAs <- apply(rts_w[, 3:7], 1, function(z) sum(is.na(z)))
rts_w <- rts_w %>% filter(numNAs < 3)  # At least three tools required


```

This excludes `r removed_assays` assays from the analysis (out of a total of `r total_assays`).


```{r outlierthreshold}
outlier.threshold <- 0.2
```

We are only interested on peaks identified by all software tools. Otherwise it is hard to interpret, since some software tools identify more peptides than others. To define when a tool picked a different peak to other software tools, for each peptide/z we estimate the standard deviation of the retention time. We consider that the peptide/z has at least one outlier if the standard deviation is higher than `r outlier.threshold` minutes, and we define as outlier the tool that has the largest deviation from the mean retention time. 


```{r outliers_3sw}

detectOutlier <- function(x){
    delta_median <- abs(x - median(as.numeric(x), na.rm = T))
    outl <- names(x)[which(delta_median == max(delta_median, na.rm=T))]
    return(outl[1])
}

detectVarianceReduction <- function(x){
    delta_median <- abs(x - median(as.numeric(x), na.rm = T))
    outl <- names(x)[which(delta_median == max(delta_median, na.rm=T))]
    x_nooutlier = x[ !names(x) %in% outl]
    stdev_nooutlier = sd(x_nooutlier, na.rm=T)
    return(stdev_nooutlier)
}

rts_w$stdev <- sqrt(apply(rts_w[, 3:7], 1, var, na.rm=T) )
rts_w$isoutlier <- rts_w$stdev >= outlier.threshold
rts_w$outlier <- apply(rts_w[, 3:7], 1, detectOutlier)
rts_w$stdev_nooutlier <- apply(rts_w[, 3:7], 1, detectVarianceReduction)

# Correct ambigous cases, i.e. where the removal of the outlier does not reduce the variance
# this means that at least one other tool also does not agree on the peak position
rts_w$outlier <- ifelse(rts_w$stdev_nooutlier > outlier.threshold, "Ambiguous", rts_w$outlier)
rts_w_unambig <- subset(rts_w, stdev_nooutlier < outlier.threshold)

summary_outliers <- rts_w_unambig %>% group_by(isoutlier) %>% summarise(cases = n())
num_outliers <- (summary_outliers %>% filter(isoutlier == T))$cases
num_no_outliers <- (summary_outliers %>% filter(isoutlier == F))$cases
percent_outliers <- round( (num_outliers / num_no_outliers) * 100, digits=1)
```

Using only unambiguous cases: 

```{r outliers_all}

tools_sorted = c("Spectronaut", "OpenSWATH", "Skyline", "SWATH2.0", "DIAumpire")
tools_sorted_colors = unname(palvector[tools_sorted])

p <- ggplot(filter(rts_w_unambig, isoutlier == T), aes(factor(outlier), fill = palvector[outlier]))
p <- p + theme_classic(base_size=15) + xlab("Tools") + ylab("number of outliers") + xlab("")
p <- p + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
               axis.text.y = element_text(size = 20),
               axis.title.y = element_text(size = 20))
p <- p + scale_fill_manual(values=tools_sorted_colors, labels=tools_sorted)
p <- p + geom_bar() 
print(p)

ggsave(filename="Figure5A_prev.pdf", plot=p)

```

We estimate there are `r percent_outliers`% of wrong peaks in the total number of peaks identified by all software tools.

```{r summaryByTool}

summary_by_tool_unambig <- rts_w %>% filter(isoutlier == T) %>%
    group_by(outlier) %>%
    summarise(Outlier.count = n(), Outlier.ratio = round(n()/nrow(rts_w_unambig) , digits=3) )


pander(summary_by_tool_unambig, style='rmarkdown')

```


Relate with peak intensities. 

```{r intensities, warning=FALSE}

int_w <- rts %>% select(Sequence, z, tool, Intensity) %>% spread(key=tool, value=Intensity)
int_w$numNAs <- apply(int_w[, 3:7], 1, function(z) sum(is.na(z)))
int_w <- int_w %>% filter(numNAs < 3)

int_rt_w <- cbind(rts_w, int_w)
names(int_rt_w) <- c(names(rts_w), paste(names(int_w), "int", sep="_"))
int_rt_w <- select(int_rt_w, -Sequence_int, -z_int, -numNAs_int)
int_rt_w$numNAs <- as.factor(int_rt_w$numNAs)
int_rt_w$outlier.color <- ifelse(int_rt_w$isoutlier, int_rt_w$outlier, "None")
int_rt_w$isoutlier <- as.factor(int_rt_w$isoutlier)
int_rt_w$z <- as.factor(int_rt_w$z)


int_rt_w$color.order = color.order[int_rt_w$outlier.color]
int_rt_w <- int_rt_w %>% arrange(color.order)
int_rt_w_sorted <- int_rt_w %>% select(OpenSWATH, SWATH2.0, Skyline, Spectronaut, DIAumpire, OpenSWATH_int, SWATH2.0_int, Skyline_int, Spectronaut_int, DIAumpire_int, outlier.color)

```


```{r intensity_and_rt}

invisible(pdf("Figure3D1.pdf", width=3.15*3, height=3.15*3))
pairs(x=int_rt_w_sorted[, 1:5], 
      #main = "Peak Retention times for all tools",
      col = palvector[int_rt_w_sorted$outlier.color], 
      xlim=c(0, 130), ylim=c(-40, 40), 
      pch=20,
      cex=.8, 
      cex.axis=1.5,
      upper.panel = panel.diff,
      lower.panel = NULL,
      text.panel = panel.txt
      )

invisible(dev.off())

invisible(pdf("Figure3D2.pdf", width=3.15*3, height=3.15*3))
pairs(x=log10(int_rt_w_sorted[, 6:10]), 
      col = palvector[int_rt_w_sorted$outlier.color],
      pch=20,
      cex=0.8,
      cex.axis=1.5,
      upper.panel=NULL,
      lower.panel=panel.pair2,
      text.panel = panel.txt
      )
invisible(dev.off())

```

